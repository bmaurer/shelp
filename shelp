#!/usr/bin/env python3
"""
shelp - AI-powered shell helper
Generates shell commands and scripts using Claude AI
"""

import argparse
import difflib
import os
import subprocess
import sys
import tempfile
import re
import shutil
import datetime
from pathlib import Path

# SHELP_PROMPT_START
# This script was built with: shelp --compile shelp-PROMPT.md
# The prompt lives in shelp-PROMPT.md alongside this script.
# To improve shelp, use: shelp --improve
# SHELP_PROMPT_END

# SHELP_CHANGELOG_START
# Changelog is maintained in shelp-PROMPT.md
# SHELP_CHANGELOG_END


def get_real_script_path():
    """Get the real path of the script, resolving symlinks."""
    return Path(os.path.realpath(__file__))


def get_prompt_file_for_script(script_path):
    """Get the -PROMPT.md file for a compiled script."""
    script_path = Path(script_path).resolve()
    prompt_file = script_path.parent / f"{script_path.name}-PROMPT.md"
    return prompt_file


def extract_embedded_prompt(script_path):
    """Extract the embedded prompt from a script file."""
    script_path = Path(script_path).resolve()
    try:
        content = script_path.read_text()
        # Look for embedded prompt markers
        match = re.search(
            r"# SHELP_PROMPT_START\n.*?SHELP_PROMPT = r'''(.+?)'''",
            content,
            re.DOTALL
        )
        if match:
            return match.group(1)
        # Try alternate format for bash scripts
        match = re.search(
            r'# SHELP_PROMPT_START\n# PROMPT: """(.+?)"""',
            content,
            re.DOTALL
        )
        if match:
            return match.group(1)
    except Exception:
        pass
    return None


def extract_changelog(script_path):
    """Extract the changelog from a script file or its PROMPT.md file."""
    script_path = Path(script_path).resolve()

    # First check for changelog in PROMPT.md file (compiled mode)
    prompt_file = get_prompt_file_for_script(script_path)
    if prompt_file.exists():
        try:
            content = prompt_file.read_text()
            # Look for changelog section at the end of PROMPT.md
            match = re.search(
                r'\n---\n\n## Changelog\n(.+)$',
                content,
                re.DOTALL
            )
            if match:
                return match.group(1).strip()
        except Exception:
            pass

    # Check for embedded changelog in script
    try:
        content = script_path.read_text()
        match = re.search(
            r"# SHELP_CHANGELOG_START\n.*?SHELP_CHANGELOG = r'''(.+?)'''",
            content,
            re.DOTALL
        )
        if match:
            return match.group(1).strip()
    except Exception:
        pass
    return None


def get_prompt_for_file(file_path):
    """Get the prompt that created a file."""
    file_path = Path(file_path).resolve()

    # Check for -PROMPT.md file first (compiled mode)
    prompt_file = get_prompt_file_for_script(file_path)
    if prompt_file.exists():
        content = prompt_file.read_text()
        # Strip changelog section from prompt if present
        if '\n---\n\n## Changelog\n' in content:
            content = content.split('\n---\n\n## Changelog\n')[0]
        return content, "compile"

    # Check for embedded prompt
    embedded = extract_embedded_prompt(file_path)
    if embedded:
        return embedded, "embedded"

    return None, None


def update_prompt_file_changelog(prompt_file, new_prompt, changelog_entry):
    """Update a PROMPT.md file with new prompt and changelog entry."""
    prompt_file = Path(prompt_file)

    # Get existing changelog
    existing_changelog = ""
    if prompt_file.exists():
        content = prompt_file.read_text()
        match = re.search(r'\n---\n\n## Changelog\n(.+)$', content, re.DOTALL)
        if match:
            existing_changelog = match.group(1)

    # Build new content
    new_changelog = existing_changelog + changelog_entry
    new_content = f"{new_prompt}\n\n---\n\n## Changelog\n{new_changelog}"
    prompt_file.write_text(new_content)


def call_claude(prompt, model=None, output_file=None):
    """Call claude CLI and return the output. Uses temp file for reliable output."""
    # Create a dedicated temp directory for this operation
    # This limits Claude's access to only this isolated directory
    temp_dir = tempfile.mkdtemp(prefix="shelp_")
    cleanup_dir = True

    try:
        # Create a temp file for claude to write to in the isolated directory
        if output_file is None:
            output_file = os.path.join(temp_dir, "output.txt")
            cleanup_output = True
        else:
            cleanup_output = False
            cleanup_dir = False

        # Build the prompt that instructs claude to write to the file
        file_prompt = f"""{prompt}

IMPORTANT: Write your output to this file: {output_file}
Do not output the content to stdout - write it directly to the file.
After writing, output only the text "DONE" to confirm completion."""

        cmd = ["claude", "-p"]
        if model:
            cmd.extend(["--model", model])

        # Add directory permissions for only the isolated temp directory
        cmd.extend(["--add-dir", temp_dir])

        # Allow Write and Read tools, and bypass permissions for temp file operations
        cmd.extend(["--allowed-tools", "Write,Read,Bash"])
        cmd.extend(["--permission-mode", "dontAsk"])

        try:
            result = subprocess.run(
                cmd,
                input=file_prompt,
                capture_output=True,
                text=True
            )
            if result.returncode != 0:
                # Only show stderr on error
                print(f"Error from claude: {result.stderr}", file=sys.stderr)
                sys.exit(1)

            # Read the output from the file
            try:
                with open(output_file, 'r') as f:
                    content = f.read().strip()
            except FileNotFoundError:
                # Fall back to stdout if file wasn't created
                content = result.stdout.strip()

            return content
        except FileNotFoundError:
            print("Error: 'claude' command not found. Please install Claude CLI.",
                  file=sys.stderr)
            sys.exit(1)
    finally:
        # Clean up the isolated temp directory
        if cleanup_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)


def open_in_editor(content):
    """Open content in the user's editor and return the modified content."""
    editor = os.environ.get("EDITOR", "vim")
    with tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False) as f:
        f.write(content)
        temp_path = f.name

    try:
        subprocess.run([editor, temp_path])
        with open(temp_path, "r") as f:
            return f.read()
    finally:
        os.unlink(temp_path)


def get_language_hint(output_file):
    """Get language hint based on output file extension."""
    if output_file:
        if output_file.endswith(".sh"):
            return "bash"
        elif output_file.endswith(".py"):
            return "python"
    return None


def build_oneliner_prompt(user_request):
    """Build the prompt for generating a one-liner command."""
    return f"""You are an expert shell programmer. Generate a single-line shell command
that accomplishes the following task:

{user_request}

Requirements:
- Output ONLY the command itself, no explanation
- It should be a single line that can be copied and pasted
- Prefer bash and classic Unix tools (awk, sed, grep, cut, tr, etc.)
- Use python -c or perl -e if it makes the solution significantly cleaner
- The command should be ready to use as-is

Output only the command, nothing else."""


def build_script_prompt(user_request, language_hint=None):
    """Build the prompt for generating a full script."""
    lang_instruction = ""
    if language_hint == "bash":
        lang_instruction = "Write the script in bash."
    elif language_hint == "python":
        lang_instruction = "Write the script in Python 3."
    else:
        lang_instruction = """Choose between bash or Python based on what's most appropriate
for the task. Use bash for simple file operations and pipelines. Use Python for more
complex logic, data manipulation, or when better error handling is needed."""

    return f"""You are an expert shell programmer. Create a complete, well-documented
executable script that accomplishes the following task:

{user_request}

Requirements:
- {lang_instruction}
- Include a proper shebang line (#!/usr/bin/env bash or #!/usr/bin/env python3)
- Add helpful comments explaining the logic
- Include basic error handling
- Make it production-ready
- Use classic Unix tools where appropriate
- The script should be self-contained and ready to run

Output only the script content, no markdown code blocks or explanations."""


def build_improve_prompt(original_prompt, current_script, new_prompt, changelog):
    """Build the prompt for improving a script."""
    return f"""You are an expert shell programmer. A user wants to improve an existing script.

ORIGINAL PROMPT THAT CREATED THE SCRIPT:
{original_prompt}

CURRENT SCRIPT:
{current_script}

UPDATED PROMPT FROM USER:
{new_prompt}

EXISTING CHANGELOG:
{changelog if changelog else "(none)"}

Your task:
1. Make INCREMENTAL edits to the existing script based on the updated prompt
2. Do NOT rewrite from scratch - preserve existing code structure and style
3. Only modify the specific parts that need to change for the new requirements
4. Maintain backwards compatibility where possible
5. Keep the same language (bash/python) unless the new requirements necessitate a change

IMPORTANT: The output should be an evolution of the existing script, not a complete rewrite.
Make minimal, targeted changes to implement the new requirements.

OUTPUT FORMAT:
First, output a brief summary of the changes you made (2-5 bullet points), wrapped like this:
---SUMMARY_START---
- Change 1
- Change 2
---SUMMARY_END---

Then output the complete updated script content (no markdown code blocks)."""


def build_tweak_prompt(original_prompt, current_script, tweak_instructions, changelog):
    """Build the prompt for tweaking a script."""
    return f"""You are an expert shell programmer. A user wants to tweak an existing script.

ORIGINAL PROMPT THAT CREATED THE SCRIPT:
{original_prompt}

CURRENT SCRIPT:
{current_script}

USER'S TWEAK INSTRUCTIONS:
{tweak_instructions}

EXISTING CHANGELOG:
{changelog if changelog else "(none)"}

Your task (two-phase approach):

PHASE 1 - Update the prompt:
First, incrementally modify the original prompt based on the user's tweak instructions.
Make minimal, targeted additions or modifications to the prompt text.
Do NOT rewrite the prompt from scratch.

PHASE 2 - Update the script:
Then, make incremental edits to the existing script to implement the tweaked requirements.
Do NOT rewrite the script from scratch - preserve existing code structure and style.
Only modify the specific parts that need to change.

IMPORTANT: Both the prompt update and script update should be evolutions, not rewrites.
Keep the same language (bash/python) unless the changes necessitate otherwise.

OUTPUT FORMAT:
First, output a brief summary of the changes you made (2-5 bullet points), wrapped like this:
---SUMMARY_START---
- Change 1
- Change 2
---SUMMARY_END---

Then output the complete updated script content (no markdown code blocks)."""


def embed_prompt_in_script(script_content, prompt, changelog=""):
    """Embed the prompt in a script for later retrieval."""
    if script_content.startswith("#!/usr/bin/env python") or \
       script_content.startswith("#!/usr/bin/python"):
        # Python script - embed as multiline string
        escaped_prompt = prompt.replace("'''", "\\'\\'\\'")
        escaped_changelog = changelog.replace("'''", "\\'\\'\\'")
        embed = f'''
# SHELP_PROMPT_START
# This is the prompt that created this script. Do not modify manually.
# To improve this script, use: shelp --improve <this_file>
SHELP_PROMPT = r\'\'\'{escaped_prompt}\'\'\'
# SHELP_PROMPT_END

# SHELP_CHANGELOG_START
SHELP_CHANGELOG = r\'\'\'{escaped_changelog}\'\'\'
# SHELP_CHANGELOG_END
'''
        # Insert after shebang
        lines = script_content.split("\n", 1)
        if len(lines) > 1:
            return lines[0] + "\n" + embed + "\n" + lines[1]
        return script_content + "\n" + embed
    else:
        # Bash script - embed as comments
        escaped_prompt = prompt.replace('"', '\\"')
        escaped_changelog = changelog.replace('"', '\\"')
        embed = f'''
# SHELP_PROMPT_START
# PROMPT: """{escaped_prompt}"""
# SHELP_PROMPT_END

# SHELP_CHANGELOG_START
# CHANGELOG: """{escaped_changelog}"""
# SHELP_CHANGELOG_END
'''
        lines = script_content.split("\n", 1)
        if len(lines) > 1:
            return lines[0] + "\n" + embed + "\n" + lines[1]
        return script_content + "\n" + embed


def strip_embedded_prompt(script_content):
    """Remove embedded prompt from script for display."""
    # Remove Python-style embedding
    script_content = re.sub(
        r'\n# SHELP_PROMPT_START\n.*?# SHELP_PROMPT_END\n',
        '\n',
        script_content,
        flags=re.DOTALL
    )
    script_content = re.sub(
        r'\n# SHELP_CHANGELOG_START\n.*?# SHELP_CHANGELOG_END\n',
        '\n',
        script_content,
        flags=re.DOTALL
    )
    # Clean up multiple blank lines
    script_content = re.sub(r'\n{3,}', '\n\n', script_content)
    return script_content


def is_in_git_repo(file_path):
    """Check if a file is inside a git repository."""
    file_path = Path(file_path).resolve()
    try:
        result = subprocess.run(
            ["git", "-C", str(file_path.parent), "rev-parse", "--git-dir"],
            capture_output=True,
            text=True
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def git_commit_files(files, message):
    """Commit the specified files with the given message."""
    if not files:
        return False

    first_file = Path(files[0]).resolve()
    git_dir = first_file.parent

    try:
        # Add the files
        for f in files:
            subprocess.run(
                ["git", "-C", str(git_dir), "add", str(Path(f).resolve())],
                check=True,
                capture_output=True
            )

        # Commit
        result = subprocess.run(
            ["git", "-C", str(git_dir), "commit", "-m", message],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            print(f"✓ Committed changes: {message}")
            return True
        else:
            print(f"Git commit failed: {result.stderr}", file=sys.stderr)
            return False
    except subprocess.CalledProcessError as e:
        print(f"Git error: {e}", file=sys.stderr)
        return False
    except FileNotFoundError:
        print("Git not found", file=sys.stderr)
        return False


def generate_diff(old_content, new_content, filename="script"):
    """Generate a unified diff between old and new content."""
    old_lines = old_content.splitlines(keepends=True)
    new_lines = new_content.splitlines(keepends=True)

    diff = difflib.unified_diff(
        old_lines, new_lines,
        fromfile=f"a/{filename}",
        tofile=f"b/{filename}",
        lineterm=""
    )
    return "".join(diff)


def parse_summary_and_script(output):
    """Parse the AI output to extract summary and script content."""
    summary = ""
    script = output

    # Look for summary markers
    summary_match = re.search(
        r'---SUMMARY_START---\s*\n(.+?)\n---SUMMARY_END---',
        output,
        re.DOTALL
    )
    if summary_match:
        summary = summary_match.group(1).strip()
        # Get everything after the summary end marker
        after_summary = output[summary_match.end():].strip()
        if after_summary:
            script = after_summary

    return summary, script


def confirm_script(script_content, prompt):
    """Show script to user and confirm it's OK. Returns (confirmed, new_prompt)."""
    display_script = strip_embedded_prompt(script_content)
    print("\n" + "=" * 60)
    print("Generated script:")
    print("=" * 60)
    print(display_script)
    print("=" * 60)

    response = input("\nDoes this look OK? [Y/n/e(dit prompt)] ").strip().lower()
    if response in ("", "y", "yes"):
        return True, prompt
    elif response in ("e", "edit"):
        new_prompt = open_in_editor(prompt)
        if new_prompt.strip() == prompt.strip():
            print("Prompt unchanged. Aborting.")
            return False, None
        return None, new_prompt  # Signal to regenerate
    else:
        print("Aborting.")
        return False, None


def confirm_changes(script_content, old_script, summary, script_path, prompt_file=None, prompt=None):
    """
    Show summary and diff for improve/tweak mode.
    Returns (action, new_prompt) where action is 'accept', 'commit', 'abort', or 'edit'.
    """
    display_script = strip_embedded_prompt(script_content)
    display_old = strip_embedded_prompt(old_script)

    # Show summary first
    if summary:
        print("\n" + "=" * 60)
        print("Summary of changes:")
        print("=" * 60)
        print(summary)

    # Show diff
    print("\n" + "=" * 60)
    print("Diff:")
    print("=" * 60)
    diff = generate_diff(display_old, display_script, script_path.name)
    if diff:
        print(diff)
    else:
        print("(no changes)")
    print("=" * 60)

    # Check if in git repo for commit option
    in_git = is_in_git_repo(script_path)

    if in_git:
        options = "[Y]es / [c]ommit / [n]o / [e]dit prompt"
        response = input(f"\nAccept changes? {options} ").strip().lower()
    else:
        options = "[Y]es / [n]o / [e]dit prompt"
        response = input(f"\nAccept changes? {options} ").strip().lower()

    if response in ("", "y", "yes"):
        return "accept", prompt
    elif response in ("c", "commit") and in_git:
        return "commit", prompt
    elif response in ("e", "edit"):
        if prompt:
            new_prompt = open_in_editor(prompt)
            if new_prompt.strip() == prompt.strip():
                print("Prompt unchanged. Aborting.")
                return "abort", None
            return "edit", new_prompt
        else:
            print("No prompt to edit in this mode.")
            return "abort", None
    else:
        print("Aborting.")
        return "abort", None


def generate_oneliner(args, model=None):
    """Generate a one-liner command."""
    user_request = " ".join(args.prompt)
    prompt = build_oneliner_prompt(user_request)
    result = call_claude(prompt, model)
    print(result)


def generate_script(args, model=None):
    """Generate a full script with -o option."""
    output_file = args.output
    user_request = " ".join(args.prompt)
    language_hint = get_language_hint(output_file)

    prompt = build_script_prompt(user_request, language_hint)

    while True:
        script = call_claude(prompt, model)
        script_with_prompt = embed_prompt_in_script(script, user_request)

        confirmed, new_prompt = confirm_script(script_with_prompt, user_request)
        if confirmed is True:
            # Write the file
            output_path = Path(output_file)
            output_path.write_text(script_with_prompt)
            output_path.chmod(0o755)
            print(f"\n✓ Script written to {output_file}")
            break
        elif confirmed is False:
            break
        else:
            # Regenerate with new prompt
            user_request = new_prompt
            prompt = build_script_prompt(user_request, language_hint)


def compile_script(args, model=None):
    """Compile from a -PROMPT.md file."""
    prompt_file = Path(args.compile)
    if not prompt_file.exists():
        print(f"Error: {prompt_file} not found", file=sys.stderr)
        sys.exit(1)

    # Derive output name from prompt file
    if prompt_file.name.endswith("-PROMPT.md"):
        output_name = prompt_file.name[:-10]  # Remove -PROMPT.md
    else:
        print("Error: Compile file should be named <command>-PROMPT.md",
              file=sys.stderr)
        sys.exit(1)

    output_path = prompt_file.parent / output_name
    user_request = prompt_file.read_text()
    language_hint = get_language_hint(output_name)

    prompt = build_script_prompt(user_request, language_hint)

    while True:
        script = call_claude(prompt, model)
        # Don't embed prompt for compile mode - use the PROMPT.md file

        confirmed, new_prompt = confirm_script(script, user_request)
        if confirmed is True:
            output_path.write_text(script)
            output_path.chmod(0o755)
            print(f"\n✓ Script written to {output_path}")
            break
        elif confirmed is False:
            break
        else:
            user_request = new_prompt
            # Update the prompt file too
            prompt_file.write_text(user_request)
            prompt = build_script_prompt(user_request, language_hint)


def improve_script(args, model=None):
    """Improve an existing script."""
    if args.improve == "" or args.improve is None:
        # Improve shelp itself
        script_path = get_real_script_path()
    else:
        script_path = Path(args.improve).resolve()

    if not script_path.exists():
        print(f"Error: {script_path} not found", file=sys.stderr)
        sys.exit(1)

    current_script = script_path.read_text()

    # Get the prompt
    original_prompt, prompt_type = get_prompt_for_file(script_path)
    if not original_prompt:
        print(f"Error: Could not find prompt for {script_path}", file=sys.stderr)
        print("Make sure the file was created with shelp -o or --compile",
              file=sys.stderr)
        sys.exit(1)

    # Get existing changelog
    changelog = extract_changelog(script_path) or ""

    # Open prompt in editor
    new_prompt = open_in_editor(original_prompt)
    if new_prompt.strip() == original_prompt.strip():
        print("Prompt unchanged. Aborting.")
        return

    # Get prompt file for compile mode
    prompt_file = get_prompt_file_for_script(script_path) if prompt_type == "compile" else None

    # Generate improved script
    ai_prompt = build_improve_prompt(original_prompt, current_script, new_prompt, changelog)

    while True:
        output = call_claude(ai_prompt, model)

        # Parse summary and script from output
        summary, script = parse_summary_and_script(output)

        # Update changelog
        new_changelog = changelog + f"\n[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}] Improved\n"

        if prompt_type == "embedded":
            script = embed_prompt_in_script(script, new_prompt, new_changelog)

        action, edited_prompt = confirm_changes(
            script, current_script, summary, script_path,
            prompt_file=prompt_file, prompt=new_prompt
        )

        if action == "accept":
            script_path.write_text(script)
            script_path.chmod(0o755)
            if prompt_type == "compile" and prompt_file:
                changelog_entry = f"\n[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}] Improved\n"
                update_prompt_file_changelog(prompt_file, new_prompt, changelog_entry)
            print(f"\n✓ Script improved: {script_path}")
            break
        elif action == "commit":
            script_path.write_text(script)
            script_path.chmod(0o755)
            files_to_commit = [str(script_path)]
            if prompt_type == "compile" and prompt_file:
                changelog_entry = f"\n[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}] Improved\n"
                update_prompt_file_changelog(prompt_file, new_prompt, changelog_entry)
                files_to_commit.append(str(prompt_file))
            print(f"\n✓ Script improved: {script_path}")
            # Commit the changes
            commit_msg = f"shelp: improve {script_path.name}"
            if summary:
                commit_msg += f"\n\n{summary}"
            git_commit_files(files_to_commit, commit_msg)
            break
        elif action == "abort":
            break
        else:  # action == "edit"
            new_prompt = edited_prompt
            ai_prompt = build_improve_prompt(original_prompt, current_script,
                                             new_prompt, changelog)


def tweak_script(args, model=None):
    """Tweak an existing script with minimal changes."""
    if args.tweak == "" or args.tweak is None:
        script_path = get_real_script_path()
    else:
        script_path = Path(args.tweak).resolve()

    if not script_path.exists():
        print(f"Error: {script_path} not found", file=sys.stderr)
        sys.exit(1)

    current_script = script_path.read_text()

    original_prompt, prompt_type = get_prompt_for_file(script_path)
    if not original_prompt:
        print(f"Error: Could not find prompt for {script_path}", file=sys.stderr)
        sys.exit(1)

    changelog = extract_changelog(script_path) or ""

    # Get prompt file for compile mode
    prompt_file = get_prompt_file_for_script(script_path) if prompt_type == "compile" else None

    # Prepare tweak editor content
    commented_prompt = "\n".join(f"# {line}" for line in original_prompt.split("\n"))
    tweak_content = f"""


# ============================================================================
# TWEAK MODE: Describe what you'd like to change above this line.
# The original prompt is shown below for reference (commented out).
# Just write your tweak instructions above, then save and exit.
# ============================================================================

{commented_prompt}
"""

    edited = open_in_editor(tweak_content)

    # Extract tweak instructions (everything before the separator)
    separator = "# ============================================================================"
    parts = edited.split(separator)
    tweak_instructions = parts[0].strip()

    if not tweak_instructions:
        print("No tweak instructions provided. Aborting.")
        return

    # Generate tweaked script
    ai_prompt = build_tweak_prompt(original_prompt, current_script,
                                   tweak_instructions, changelog)

    while True:
        output = call_claude(ai_prompt, model)

        # Parse summary and script from output
        summary, script = parse_summary_and_script(output)

        new_changelog = changelog + f"\n[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}] Tweaked: {tweak_instructions[:50]}...\n"

        if prompt_type == "embedded":
            script = embed_prompt_in_script(script, original_prompt, new_changelog)

        action, _ = confirm_changes(
            script, current_script, summary, script_path,
            prompt_file=prompt_file, prompt=None  # No prompt editing in tweak mode
        )

        if action == "accept":
            script_path.write_text(script)
            script_path.chmod(0o755)
            if prompt_type == "compile" and prompt_file:
                changelog_entry = f"\n[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}] Tweaked: {tweak_instructions[:50]}...\n"
                update_prompt_file_changelog(prompt_file, original_prompt, changelog_entry)
            print(f"\n✓ Script tweaked: {script_path}")
            break
        elif action == "commit":
            script_path.write_text(script)
            script_path.chmod(0o755)
            files_to_commit = [str(script_path)]
            if prompt_type == "compile" and prompt_file:
                changelog_entry = f"\n[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}] Tweaked: {tweak_instructions[:50]}...\n"
                update_prompt_file_changelog(prompt_file, original_prompt, changelog_entry)
                files_to_commit.append(str(prompt_file))
            print(f"\n✓ Script tweaked: {script_path}")
            # Commit the changes
            commit_msg = f"shelp: tweak {script_path.name} - {tweak_instructions[:50]}"
            if summary:
                commit_msg += f"\n\n{summary}"
            git_commit_files(files_to_commit, commit_msg)
            break
        else:  # action == "abort" or "edit" (edit not available in tweak mode)
            print("Aborting.")
            break


def show_prompt(args):
    """Show the prompt that created a file."""
    if args.prompt_file == "" or args.prompt_file is None:
        script_path = get_real_script_path()
    else:
        script_path = Path(args.prompt_file).resolve()

    if not script_path.exists():
        print(f"Error: {script_path} not found", file=sys.stderr)
        sys.exit(1)

    prompt, prompt_type = get_prompt_for_file(script_path)
    if not prompt:
        print(f"Error: Could not find prompt for {script_path}", file=sys.stderr)
        sys.exit(1)

    print(f"Prompt for {script_path}:\n")
    print("=" * 60)
    print(prompt)
    print("=" * 60)

    changelog = extract_changelog(script_path)
    if changelog:
        print("\nChangelog:")
        print(changelog)


def install_shelp(args):
    """Install shelp to a directory."""
    install_dir = Path(args.install if args.install else "~/bin").expanduser()

    # Create directory if it doesn't exist
    if not install_dir.exists():
        print(f"Creating directory: {install_dir}")
        install_dir.mkdir(parents=True)

    # Copy shelp to install directory
    script_path = get_real_script_path()
    dest_path = install_dir / "shelp"

    import shutil
    shutil.copy2(script_path, dest_path)
    dest_path.chmod(0o755)

    # Also copy prompt file if it exists
    prompt_file = get_prompt_file_for_script(script_path)
    if prompt_file.exists():
        shutil.copy2(prompt_file, install_dir / prompt_file.name)

    print(f"✓ Installed shelp to {dest_path}")

    # Check if directory is in PATH
    path_dirs = os.environ.get("PATH", "").split(":")
    install_dir_str = str(install_dir)

    if install_dir_str not in path_dirs:
        bashrc = Path("~/.bashrc").expanduser()
        response = input(f"\n{install_dir} is not in your PATH. Add it to ~/.bashrc? [Y/n] ")
        if response.strip().lower() in ("", "y", "yes"):
            with open(bashrc, "a") as f:
                f.write(f'\n# Added by shelp\nexport PATH="$PATH:{install_dir_str}"\n')
            print(f"✓ Added {install_dir} to PATH in ~/.bashrc")
            print("  Run 'source ~/.bashrc' or start a new terminal to use shelp")
    else:
        print(f"✓ {install_dir} is already in your PATH")


def show_help():
    """Show detailed help with examples."""
    help_text = """
shelp - AI-Powered Shell Helper
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Generate shell commands and scripts using Claude AI.

USAGE
  shelp <description>              Generate a one-liner command
  shelp -o <file> <description>    Generate and save a full script
  shelp --compile <file>-PROMPT.md Compile a prompt file to a script
  shelp --improve [file]           Improve an existing script's prompt
  shelp --tweak [file]             Make small tweaks to a script
  shelp --prompt [file]            Show the prompt that created a file
  shelp --install [dir]            Install shelp to a directory

OPTIONS
  -o, --output FILE    Write output to FILE (creates executable)
  --compile FILE       Compile from FILE-PROMPT.md
  --improve [FILE]     Improve existing script (default: shelp)
  --tweak [FILE]       Tweak existing script
  --prompt [FILE]      Show prompt for FILE (default: shelp)
  --install [DIR]      Install to DIR (default: ~/bin)
  --model MODEL        Use specified Claude model
  --opus               Use claude-opus-4-5 model
  --help               Show this help

EXAMPLES

  Quick One-Liners:
  ─────────────────
  shelp find all python files modified today
  shelp count lines of code in src directory excluding tests
  shelp extract email addresses from input.txt
  shelp convert CSV to JSON from stdin

  Creating Scripts:
  ─────────────────
  shelp -o backup.sh backup my home directory to /mnt/backup daily
  shelp -o analyze.py analyze apache logs and report top IPs
  shelp -o deploy.sh deploy docker containers with rollback support

  Compilation Mode:
  ─────────────────
  1. Create mycommand-PROMPT.md with your requirements
  2. Run: shelp --compile mycommand-PROMPT.md
  3. Edit and improve: shelp --improve mycommand

  Improving Scripts:
  ──────────────────
  shelp --improve myscript.sh     # Edit the prompt, regenerate
  shelp --tweak myscript.sh       # Quick tweaks without full rewrite
  shelp --improve                 # Improve shelp itself!

  Using Different Models:
  ───────────────────────
  shelp --opus find memory leaks in this process
  shelp --model claude-sonnet-4-5-20250929 optimize this query

"""
    print(help_text)


def main():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("-o", "--output", help="Output file for script")
    parser.add_argument("--compile", help="Compile from PROMPT.md file")
    parser.add_argument("--improve", nargs="?", const="",
                        help="Improve a script")
    parser.add_argument("--tweak", nargs="?", const="",
                        help="Tweak a script")
    parser.add_argument("--prompt", dest="prompt_file", nargs="?", const="",
                        help="Show prompt for a file")
    parser.add_argument("--install", nargs="?", const="",
                        help="Install shelp")
    parser.add_argument("--model", help="Claude model to use")
    parser.add_argument("--opus", action="store_true",
                        help="Use claude-opus-4-5 model")
    parser.add_argument("--help", action="store_true", help="Show help")
    parser.add_argument("prompt", nargs="*", help="The prompt/description")

    args = parser.parse_args()

    # Determine model
    model = args.model
    if args.opus:
        model = "claude-opus-4-5"

    if args.help:
        show_help()
    elif args.install is not None:
        install_shelp(args)
    elif args.compile:
        compile_script(args, model)
    elif args.improve is not None:
        improve_script(args, model)
    elif args.tweak is not None:
        tweak_script(args, model)
    elif args.prompt_file is not None:
        show_prompt(args)
    elif args.output:
        if not args.prompt:
            print("Error: Please provide a description for the script",
                  file=sys.stderr)
            sys.exit(1)
        generate_script(args, model)
    elif args.prompt:
        generate_oneliner(args, model)
    else:
        show_help()


if __name__ == "__main__":
    main()
